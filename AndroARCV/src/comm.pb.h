// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "image_features.pb.h"
// @@protoc_insertion_point(includes)

namespace androar {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class AuthentificationInfo;
class ClientMessage;
class AuthentificationNewKey;
class ServerMessage;
class OpenCVRequest;

enum ClientMessage_ClientMessageType {
  ClientMessage_ClientMessageType_UNDEFINED = 1,
  ClientMessage_ClientMessageType_IMAGE_TO_PROCESS = 2,
  ClientMessage_ClientMessageType_IMAGES_TO_STORE = 3,
  ClientMessage_ClientMessageType_LAST_MESSAGE = 4
};
bool ClientMessage_ClientMessageType_IsValid(int value);
const ClientMessage_ClientMessageType ClientMessage_ClientMessageType_ClientMessageType_MIN = ClientMessage_ClientMessageType_UNDEFINED;
const ClientMessage_ClientMessageType ClientMessage_ClientMessageType_ClientMessageType_MAX = ClientMessage_ClientMessageType_LAST_MESSAGE;
const int ClientMessage_ClientMessageType_ClientMessageType_ARRAYSIZE = ClientMessage_ClientMessageType_ClientMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientMessage_ClientMessageType_descriptor();
inline const ::std::string& ClientMessage_ClientMessageType_Name(ClientMessage_ClientMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientMessage_ClientMessageType_descriptor(), value);
}
inline bool ClientMessage_ClientMessageType_Parse(
    const ::std::string& name, ClientMessage_ClientMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientMessage_ClientMessageType>(
    ClientMessage_ClientMessageType_descriptor(), name, value);
}
enum ServerMessage_ServerMessageType {
  ServerMessage_ServerMessageType_UNDEFINED = 1,
  ServerMessage_ServerMessageType_HELLO_MESSAGE = 2,
  ServerMessage_ServerMessageType_AUTHENTIFICATION_DENIED = 3,
  ServerMessage_ServerMessageType_AUTHENTIFICATION_NEW_KEY = 4,
  ServerMessage_ServerMessageType_IMAGE_PROCESSED = 5,
  ServerMessage_ServerMessageType_LAST_MESSAGE = 6
};
bool ServerMessage_ServerMessageType_IsValid(int value);
const ServerMessage_ServerMessageType ServerMessage_ServerMessageType_ServerMessageType_MIN = ServerMessage_ServerMessageType_UNDEFINED;
const ServerMessage_ServerMessageType ServerMessage_ServerMessageType_ServerMessageType_MAX = ServerMessage_ServerMessageType_LAST_MESSAGE;
const int ServerMessage_ServerMessageType_ServerMessageType_ARRAYSIZE = ServerMessage_ServerMessageType_ServerMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerMessage_ServerMessageType_descriptor();
inline const ::std::string& ServerMessage_ServerMessageType_Name(ServerMessage_ServerMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerMessage_ServerMessageType_descriptor(), value);
}
inline bool ServerMessage_ServerMessageType_Parse(
    const ::std::string& name, ServerMessage_ServerMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerMessage_ServerMessageType>(
    ServerMessage_ServerMessageType_descriptor(), name, value);
}
enum OpenCVRequest_RequestType {
  OpenCVRequest_RequestType_STORE = 1,
  OpenCVRequest_RequestType_QUERY = 2
};
bool OpenCVRequest_RequestType_IsValid(int value);
const OpenCVRequest_RequestType OpenCVRequest_RequestType_RequestType_MIN = OpenCVRequest_RequestType_STORE;
const OpenCVRequest_RequestType OpenCVRequest_RequestType_RequestType_MAX = OpenCVRequest_RequestType_QUERY;
const int OpenCVRequest_RequestType_RequestType_ARRAYSIZE = OpenCVRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpenCVRequest_RequestType_descriptor();
inline const ::std::string& OpenCVRequest_RequestType_Name(OpenCVRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpenCVRequest_RequestType_descriptor(), value);
}
inline bool OpenCVRequest_RequestType_Parse(
    const ::std::string& name, OpenCVRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpenCVRequest_RequestType>(
    OpenCVRequest_RequestType_descriptor(), name, value);
}
// ===================================================================

class AuthentificationInfo : public ::google::protobuf::Message {
 public:
  AuthentificationInfo();
  virtual ~AuthentificationInfo();
  
  AuthentificationInfo(const AuthentificationInfo& from);
  
  inline AuthentificationInfo& operator=(const AuthentificationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthentificationInfo& default_instance();
  
  void Swap(AuthentificationInfo* other);
  
  // implements Message ----------------------------------------------
  
  AuthentificationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthentificationInfo& from);
  void MergeFrom(const AuthentificationInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string phone_id = 1;
  inline bool has_phone_id() const;
  inline void clear_phone_id();
  static const int kPhoneIdFieldNumber = 1;
  inline const ::std::string& phone_id() const;
  inline void set_phone_id(const ::std::string& value);
  inline void set_phone_id(const char* value);
  inline void set_phone_id(const char* value, size_t size);
  inline ::std::string* mutable_phone_id();
  inline ::std::string* release_phone_id();
  
  // required string hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // @@protoc_insertion_point(class_scope:androar.AuthentificationInfo)
 private:
  inline void set_has_phone_id();
  inline void clear_has_phone_id();
  inline void set_has_hash();
  inline void clear_has_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* phone_id_;
  ::std::string* hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static AuthentificationInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message {
 public:
  ClientMessage();
  virtual ~ClientMessage();
  
  ClientMessage(const ClientMessage& from);
  
  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();
  
  void Swap(ClientMessage* other);
  
  // implements Message ----------------------------------------------
  
  ClientMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientMessage_ClientMessageType ClientMessageType;
  static const ClientMessageType UNDEFINED = ClientMessage_ClientMessageType_UNDEFINED;
  static const ClientMessageType IMAGE_TO_PROCESS = ClientMessage_ClientMessageType_IMAGE_TO_PROCESS;
  static const ClientMessageType IMAGES_TO_STORE = ClientMessage_ClientMessageType_IMAGES_TO_STORE;
  static const ClientMessageType LAST_MESSAGE = ClientMessage_ClientMessageType_LAST_MESSAGE;
  static inline bool ClientMessageType_IsValid(int value) {
    return ClientMessage_ClientMessageType_IsValid(value);
  }
  static const ClientMessageType ClientMessageType_MIN =
    ClientMessage_ClientMessageType_ClientMessageType_MIN;
  static const ClientMessageType ClientMessageType_MAX =
    ClientMessage_ClientMessageType_ClientMessageType_MAX;
  static const int ClientMessageType_ARRAYSIZE =
    ClientMessage_ClientMessageType_ClientMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ClientMessageType_descriptor() {
    return ClientMessage_ClientMessageType_descriptor();
  }
  static inline const ::std::string& ClientMessageType_Name(ClientMessageType value) {
    return ClientMessage_ClientMessageType_Name(value);
  }
  static inline bool ClientMessageType_Parse(const ::std::string& name,
      ClientMessageType* value) {
    return ClientMessage_ClientMessageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .androar.AuthentificationInfo authentification_info = 1;
  inline bool has_authentification_info() const;
  inline void clear_authentification_info();
  static const int kAuthentificationInfoFieldNumber = 1;
  inline const ::androar::AuthentificationInfo& authentification_info() const;
  inline ::androar::AuthentificationInfo* mutable_authentification_info();
  inline ::androar::AuthentificationInfo* release_authentification_info();
  
  // required .androar.ClientMessage.ClientMessageType message_type = 2;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  inline ::androar::ClientMessage_ClientMessageType message_type() const;
  inline void set_message_type(::androar::ClientMessage_ClientMessageType value);
  
  // optional .androar.Image image_to_process = 10;
  inline bool has_image_to_process() const;
  inline void clear_image_to_process();
  static const int kImageToProcessFieldNumber = 10;
  inline const ::androar::Image& image_to_process() const;
  inline ::androar::Image* mutable_image_to_process();
  inline ::androar::Image* release_image_to_process();
  
  // repeated .androar.Image images_to_store = 11;
  inline int images_to_store_size() const;
  inline void clear_images_to_store();
  static const int kImagesToStoreFieldNumber = 11;
  inline const ::androar::Image& images_to_store(int index) const;
  inline ::androar::Image* mutable_images_to_store(int index);
  inline ::androar::Image* add_images_to_store();
  inline const ::google::protobuf::RepeatedPtrField< ::androar::Image >&
      images_to_store() const;
  inline ::google::protobuf::RepeatedPtrField< ::androar::Image >*
      mutable_images_to_store();
  
  // @@protoc_insertion_point(class_scope:androar.ClientMessage)
 private:
  inline void set_has_authentification_info();
  inline void clear_has_authentification_info();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_image_to_process();
  inline void clear_has_image_to_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::androar::AuthentificationInfo* authentification_info_;
  ::androar::Image* image_to_process_;
  ::google::protobuf::RepeatedPtrField< ::androar::Image > images_to_store_;
  int message_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthentificationNewKey : public ::google::protobuf::Message {
 public:
  AuthentificationNewKey();
  virtual ~AuthentificationNewKey();
  
  AuthentificationNewKey(const AuthentificationNewKey& from);
  
  inline AuthentificationNewKey& operator=(const AuthentificationNewKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthentificationNewKey& default_instance();
  
  void Swap(AuthentificationNewKey* other);
  
  // implements Message ----------------------------------------------
  
  AuthentificationNewKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthentificationNewKey& from);
  void MergeFrom(const AuthentificationNewKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string new_hash = 1;
  inline bool has_new_hash() const;
  inline void clear_new_hash();
  static const int kNewHashFieldNumber = 1;
  inline const ::std::string& new_hash() const;
  inline void set_new_hash(const ::std::string& value);
  inline void set_new_hash(const char* value);
  inline void set_new_hash(const char* value, size_t size);
  inline ::std::string* mutable_new_hash();
  inline ::std::string* release_new_hash();
  
  // @@protoc_insertion_point(class_scope:androar.AuthentificationNewKey)
 private:
  inline void set_has_new_hash();
  inline void clear_has_new_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* new_hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static AuthentificationNewKey* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message {
 public:
  ServerMessage();
  virtual ~ServerMessage();
  
  ServerMessage(const ServerMessage& from);
  
  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();
  
  void Swap(ServerMessage* other);
  
  // implements Message ----------------------------------------------
  
  ServerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerMessage_ServerMessageType ServerMessageType;
  static const ServerMessageType UNDEFINED = ServerMessage_ServerMessageType_UNDEFINED;
  static const ServerMessageType HELLO_MESSAGE = ServerMessage_ServerMessageType_HELLO_MESSAGE;
  static const ServerMessageType AUTHENTIFICATION_DENIED = ServerMessage_ServerMessageType_AUTHENTIFICATION_DENIED;
  static const ServerMessageType AUTHENTIFICATION_NEW_KEY = ServerMessage_ServerMessageType_AUTHENTIFICATION_NEW_KEY;
  static const ServerMessageType IMAGE_PROCESSED = ServerMessage_ServerMessageType_IMAGE_PROCESSED;
  static const ServerMessageType LAST_MESSAGE = ServerMessage_ServerMessageType_LAST_MESSAGE;
  static inline bool ServerMessageType_IsValid(int value) {
    return ServerMessage_ServerMessageType_IsValid(value);
  }
  static const ServerMessageType ServerMessageType_MIN =
    ServerMessage_ServerMessageType_ServerMessageType_MIN;
  static const ServerMessageType ServerMessageType_MAX =
    ServerMessage_ServerMessageType_ServerMessageType_MAX;
  static const int ServerMessageType_ARRAYSIZE =
    ServerMessage_ServerMessageType_ServerMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ServerMessageType_descriptor() {
    return ServerMessage_ServerMessageType_descriptor();
  }
  static inline const ::std::string& ServerMessageType_Name(ServerMessageType value) {
    return ServerMessage_ServerMessageType_Name(value);
  }
  static inline bool ServerMessageType_Parse(const ::std::string& name,
      ServerMessageType* value) {
    return ServerMessage_ServerMessageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .androar.ServerMessage.ServerMessageType message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::androar::ServerMessage_ServerMessageType message_type() const;
  inline void set_message_type(::androar::ServerMessage_ServerMessageType value);
  
  // optional .androar.AuthentificationNewKey authentification_new_key = 14;
  inline bool has_authentification_new_key() const;
  inline void clear_authentification_new_key();
  static const int kAuthentificationNewKeyFieldNumber = 14;
  inline const ::androar::AuthentificationNewKey& authentification_new_key() const;
  inline ::androar::AuthentificationNewKey* mutable_authentification_new_key();
  inline ::androar::AuthentificationNewKey* release_authentification_new_key();
  
  // optional .androar.Image processed_image = 15;
  inline bool has_processed_image() const;
  inline void clear_processed_image();
  static const int kProcessedImageFieldNumber = 15;
  inline const ::androar::Image& processed_image() const;
  inline ::androar::Image* mutable_processed_image();
  inline ::androar::Image* release_processed_image();
  
  // @@protoc_insertion_point(class_scope:androar.ServerMessage)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_authentification_new_key();
  inline void clear_has_authentification_new_key();
  inline void set_has_processed_image();
  inline void clear_has_processed_image();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::androar::AuthentificationNewKey* authentification_new_key_;
  ::androar::Image* processed_image_;
  int message_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class OpenCVRequest : public ::google::protobuf::Message {
 public:
  OpenCVRequest();
  virtual ~OpenCVRequest();
  
  OpenCVRequest(const OpenCVRequest& from);
  
  inline OpenCVRequest& operator=(const OpenCVRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenCVRequest& default_instance();
  
  void Swap(OpenCVRequest* other);
  
  // implements Message ----------------------------------------------
  
  OpenCVRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenCVRequest& from);
  void MergeFrom(const OpenCVRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OpenCVRequest_RequestType RequestType;
  static const RequestType STORE = OpenCVRequest_RequestType_STORE;
  static const RequestType QUERY = OpenCVRequest_RequestType_QUERY;
  static inline bool RequestType_IsValid(int value) {
    return OpenCVRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    OpenCVRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    OpenCVRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    OpenCVRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return OpenCVRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return OpenCVRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return OpenCVRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .androar.OpenCVRequest.RequestType request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::androar::OpenCVRequest_RequestType request_type() const;
  inline void set_request_type(::androar::OpenCVRequest_RequestType value);
  
  // required .androar.Image image_contents = 2;
  inline bool has_image_contents() const;
  inline void clear_image_contents();
  static const int kImageContentsFieldNumber = 2;
  inline const ::androar::Image& image_contents() const;
  inline ::androar::Image* mutable_image_contents();
  inline ::androar::Image* release_image_contents();
  
  // @@protoc_insertion_point(class_scope:androar.OpenCVRequest)
 private:
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_image_contents();
  inline void clear_has_image_contents();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::androar::Image* image_contents_;
  int request_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static OpenCVRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// AuthentificationInfo

// required string phone_id = 1;
inline bool AuthentificationInfo::has_phone_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthentificationInfo::set_has_phone_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthentificationInfo::clear_has_phone_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthentificationInfo::clear_phone_id() {
  if (phone_id_ != &::google::protobuf::internal::kEmptyString) {
    phone_id_->clear();
  }
  clear_has_phone_id();
}
inline const ::std::string& AuthentificationInfo::phone_id() const {
  return *phone_id_;
}
inline void AuthentificationInfo::set_phone_id(const ::std::string& value) {
  set_has_phone_id();
  if (phone_id_ == &::google::protobuf::internal::kEmptyString) {
    phone_id_ = new ::std::string;
  }
  phone_id_->assign(value);
}
inline void AuthentificationInfo::set_phone_id(const char* value) {
  set_has_phone_id();
  if (phone_id_ == &::google::protobuf::internal::kEmptyString) {
    phone_id_ = new ::std::string;
  }
  phone_id_->assign(value);
}
inline void AuthentificationInfo::set_phone_id(const char* value, size_t size) {
  set_has_phone_id();
  if (phone_id_ == &::google::protobuf::internal::kEmptyString) {
    phone_id_ = new ::std::string;
  }
  phone_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthentificationInfo::mutable_phone_id() {
  set_has_phone_id();
  if (phone_id_ == &::google::protobuf::internal::kEmptyString) {
    phone_id_ = new ::std::string;
  }
  return phone_id_;
}
inline ::std::string* AuthentificationInfo::release_phone_id() {
  clear_has_phone_id();
  if (phone_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_id_;
    phone_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string hash = 2;
inline bool AuthentificationInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthentificationInfo::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthentificationInfo::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthentificationInfo::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& AuthentificationInfo::hash() const {
  return *hash_;
}
inline void AuthentificationInfo::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void AuthentificationInfo::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void AuthentificationInfo::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthentificationInfo::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* AuthentificationInfo::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientMessage

// required .androar.AuthentificationInfo authentification_info = 1;
inline bool ClientMessage::has_authentification_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_authentification_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_authentification_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_authentification_info() {
  if (authentification_info_ != NULL) authentification_info_->::androar::AuthentificationInfo::Clear();
  clear_has_authentification_info();
}
inline const ::androar::AuthentificationInfo& ClientMessage::authentification_info() const {
  return authentification_info_ != NULL ? *authentification_info_ : *default_instance_->authentification_info_;
}
inline ::androar::AuthentificationInfo* ClientMessage::mutable_authentification_info() {
  set_has_authentification_info();
  if (authentification_info_ == NULL) authentification_info_ = new ::androar::AuthentificationInfo;
  return authentification_info_;
}
inline ::androar::AuthentificationInfo* ClientMessage::release_authentification_info() {
  clear_has_authentification_info();
  ::androar::AuthentificationInfo* temp = authentification_info_;
  authentification_info_ = NULL;
  return temp;
}

// required .androar.ClientMessage.ClientMessageType message_type = 2;
inline bool ClientMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_message_type() {
  message_type_ = 1;
  clear_has_message_type();
}
inline ::androar::ClientMessage_ClientMessageType ClientMessage::message_type() const {
  return static_cast< ::androar::ClientMessage_ClientMessageType >(message_type_);
}
inline void ClientMessage::set_message_type(::androar::ClientMessage_ClientMessageType value) {
  GOOGLE_DCHECK(::androar::ClientMessage_ClientMessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// optional .androar.Image image_to_process = 10;
inline bool ClientMessage::has_image_to_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_image_to_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_image_to_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_image_to_process() {
  if (image_to_process_ != NULL) image_to_process_->::androar::Image::Clear();
  clear_has_image_to_process();
}
inline const ::androar::Image& ClientMessage::image_to_process() const {
  return image_to_process_ != NULL ? *image_to_process_ : *default_instance_->image_to_process_;
}
inline ::androar::Image* ClientMessage::mutable_image_to_process() {
  set_has_image_to_process();
  if (image_to_process_ == NULL) image_to_process_ = new ::androar::Image;
  return image_to_process_;
}
inline ::androar::Image* ClientMessage::release_image_to_process() {
  clear_has_image_to_process();
  ::androar::Image* temp = image_to_process_;
  image_to_process_ = NULL;
  return temp;
}

// repeated .androar.Image images_to_store = 11;
inline int ClientMessage::images_to_store_size() const {
  return images_to_store_.size();
}
inline void ClientMessage::clear_images_to_store() {
  images_to_store_.Clear();
}
inline const ::androar::Image& ClientMessage::images_to_store(int index) const {
  return images_to_store_.Get(index);
}
inline ::androar::Image* ClientMessage::mutable_images_to_store(int index) {
  return images_to_store_.Mutable(index);
}
inline ::androar::Image* ClientMessage::add_images_to_store() {
  return images_to_store_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::androar::Image >&
ClientMessage::images_to_store() const {
  return images_to_store_;
}
inline ::google::protobuf::RepeatedPtrField< ::androar::Image >*
ClientMessage::mutable_images_to_store() {
  return &images_to_store_;
}

// -------------------------------------------------------------------

// AuthentificationNewKey

// required string new_hash = 1;
inline bool AuthentificationNewKey::has_new_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthentificationNewKey::set_has_new_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthentificationNewKey::clear_has_new_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthentificationNewKey::clear_new_hash() {
  if (new_hash_ != &::google::protobuf::internal::kEmptyString) {
    new_hash_->clear();
  }
  clear_has_new_hash();
}
inline const ::std::string& AuthentificationNewKey::new_hash() const {
  return *new_hash_;
}
inline void AuthentificationNewKey::set_new_hash(const ::std::string& value) {
  set_has_new_hash();
  if (new_hash_ == &::google::protobuf::internal::kEmptyString) {
    new_hash_ = new ::std::string;
  }
  new_hash_->assign(value);
}
inline void AuthentificationNewKey::set_new_hash(const char* value) {
  set_has_new_hash();
  if (new_hash_ == &::google::protobuf::internal::kEmptyString) {
    new_hash_ = new ::std::string;
  }
  new_hash_->assign(value);
}
inline void AuthentificationNewKey::set_new_hash(const char* value, size_t size) {
  set_has_new_hash();
  if (new_hash_ == &::google::protobuf::internal::kEmptyString) {
    new_hash_ = new ::std::string;
  }
  new_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthentificationNewKey::mutable_new_hash() {
  set_has_new_hash();
  if (new_hash_ == &::google::protobuf::internal::kEmptyString) {
    new_hash_ = new ::std::string;
  }
  return new_hash_;
}
inline ::std::string* AuthentificationNewKey::release_new_hash() {
  clear_has_new_hash();
  if (new_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_hash_;
    new_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerMessage

// required .androar.ServerMessage.ServerMessageType message_type = 1;
inline bool ServerMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_message_type() {
  message_type_ = 1;
  clear_has_message_type();
}
inline ::androar::ServerMessage_ServerMessageType ServerMessage::message_type() const {
  return static_cast< ::androar::ServerMessage_ServerMessageType >(message_type_);
}
inline void ServerMessage::set_message_type(::androar::ServerMessage_ServerMessageType value) {
  GOOGLE_DCHECK(::androar::ServerMessage_ServerMessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// optional .androar.AuthentificationNewKey authentification_new_key = 14;
inline bool ServerMessage::has_authentification_new_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_authentification_new_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_authentification_new_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_authentification_new_key() {
  if (authentification_new_key_ != NULL) authentification_new_key_->::androar::AuthentificationNewKey::Clear();
  clear_has_authentification_new_key();
}
inline const ::androar::AuthentificationNewKey& ServerMessage::authentification_new_key() const {
  return authentification_new_key_ != NULL ? *authentification_new_key_ : *default_instance_->authentification_new_key_;
}
inline ::androar::AuthentificationNewKey* ServerMessage::mutable_authentification_new_key() {
  set_has_authentification_new_key();
  if (authentification_new_key_ == NULL) authentification_new_key_ = new ::androar::AuthentificationNewKey;
  return authentification_new_key_;
}
inline ::androar::AuthentificationNewKey* ServerMessage::release_authentification_new_key() {
  clear_has_authentification_new_key();
  ::androar::AuthentificationNewKey* temp = authentification_new_key_;
  authentification_new_key_ = NULL;
  return temp;
}

// optional .androar.Image processed_image = 15;
inline bool ServerMessage::has_processed_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_processed_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_processed_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_processed_image() {
  if (processed_image_ != NULL) processed_image_->::androar::Image::Clear();
  clear_has_processed_image();
}
inline const ::androar::Image& ServerMessage::processed_image() const {
  return processed_image_ != NULL ? *processed_image_ : *default_instance_->processed_image_;
}
inline ::androar::Image* ServerMessage::mutable_processed_image() {
  set_has_processed_image();
  if (processed_image_ == NULL) processed_image_ = new ::androar::Image;
  return processed_image_;
}
inline ::androar::Image* ServerMessage::release_processed_image() {
  clear_has_processed_image();
  ::androar::Image* temp = processed_image_;
  processed_image_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OpenCVRequest

// required .androar.OpenCVRequest.RequestType request_type = 1;
inline bool OpenCVRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenCVRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenCVRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenCVRequest::clear_request_type() {
  request_type_ = 1;
  clear_has_request_type();
}
inline ::androar::OpenCVRequest_RequestType OpenCVRequest::request_type() const {
  return static_cast< ::androar::OpenCVRequest_RequestType >(request_type_);
}
inline void OpenCVRequest::set_request_type(::androar::OpenCVRequest_RequestType value) {
  GOOGLE_DCHECK(::androar::OpenCVRequest_RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// required .androar.Image image_contents = 2;
inline bool OpenCVRequest::has_image_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenCVRequest::set_has_image_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenCVRequest::clear_has_image_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenCVRequest::clear_image_contents() {
  if (image_contents_ != NULL) image_contents_->::androar::Image::Clear();
  clear_has_image_contents();
}
inline const ::androar::Image& OpenCVRequest::image_contents() const {
  return image_contents_ != NULL ? *image_contents_ : *default_instance_->image_contents_;
}
inline ::androar::Image* OpenCVRequest::mutable_image_contents() {
  set_has_image_contents();
  if (image_contents_ == NULL) image_contents_ = new ::androar::Image;
  return image_contents_;
}
inline ::androar::Image* OpenCVRequest::release_image_contents() {
  clear_has_image_contents();
  ::androar::Image* temp = image_contents_;
  image_contents_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace androar

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::androar::ClientMessage_ClientMessageType>() {
  return ::androar::ClientMessage_ClientMessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::androar::ServerMessage_ServerMessageType>() {
  return ::androar::ServerMessage_ServerMessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::androar::OpenCVRequest_RequestType>() {
  return ::androar::OpenCVRequest_RequestType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
